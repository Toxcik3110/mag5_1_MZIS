SQL-injection - це спосіб атаки на веб-сервер, в ході якої використовуеться SQL вираз який складається з того що було і доданого коду за допомогою простої конкатенації строки. При цьому запит який виконується є несанкціонований. Ця непередбачуванність лежить на стику веб-технології і SQL.

SQL-ін'єкція може проходити як під час атаки, так і пізніше (із другого місця виконуватись код (із БД)).

# З чого починають перевірку на вразливість - добавити апостроф в кінці запиту:

	http://site.com/page.php?id=23'

це неправильний урл, хоча але логіка яка закладена у цьому варіанті нарушається

як це було в скрипті:

	$id = $GET['id']
	$sql = "SELECT * FROM Tabs WHERE id='$id';
	$res = mysql.query($query) or die(mysql.error());
	$row = mysql.fetch_array($res) or die("незнайдено")

1. пуста відповідь
2. нормальна відповідь
3. помилка

# Види SQL-injection

## По типу змінної

тип змінної:
- Цілочисленна (id=$id)
- Строкова (id='$id')

## По типу запиту і місця ін'єкції в запиті

Начастіше в селекті, рідше в апдейт інсерт деліт

## Спосіб передачі

- GET
- POST
- coockie
- HTTP-header : referer, agent
- second order injection (коли дані попадають не напряму із запиту а беруться із БД або файлу)

## По типу SQL-injection

1. Union-based ()
	
	http://site.com/page.php?id=1'union select 1.2.3 --+

	ми намагаємось дізнатись кількість рядків у таблиці

2. Error-based (використовується коли ін'єкція відбувається в запиті, який не виводить інформацію на сторінку або не впливає на вивід. Корисну інформацію можно отримати з повідомлення помилки)

	Duplicate entry - запит, за допомогою якого веб-сервер можно повернути копію запису (двічі в БД є запис з однаковим айді, але айді унікальний і тому викине помилку з назвою ключа в якого не унікальне ім'я)

3. Blind-based (просто сліпа ін'єкція - спосіб атаки на БД в обхід між-мережевого захисту, при цьому атакуючий маніпулює логікою роботи додатка. Повідомлення може як повертатися, так і не повертатися)

	id=-1 or 1=1 - задання неіснуючого ідентифікатора і умовний вираз який завжди правильний (або навпаки - неправильний)

	id = -1"/*

4. Time-based Double-blinded - грунтується на часових затримках: на основі часу затримки (коли повертається відповідь від веб-серверу) зловмисник вгадав атаку. Щоб користуватися цими затримками використовються такі функції:
- benchmark('count', expr) - виконує вказану кількість разів вираз
- sleep(sec)) - припиняє процесс на вказану кількість секунд, наприклад:

	id=-1 AND benchmark(2000, mds(now())) //двісті раз обчислюється хеш поточної дати

якщо це MySQL, то деяку інформацію про таблиці можна знайти в представленнях:

	InformationSchema.columns
	InformationSchema.tables

# Інструментарій для тестування

## sqlmap

це программа для тестування веб-додатків на впровадження скл-ін'єкцій, для її використання повинен бути встановлений пайтон (в дистрибутиві калі є також портована под віндовс(???))

	sqlmap -u http://site.com/page.php?id=23 --Dbs
	ключ -u задає урл атакованого сайта
	ключ --Dbs виведе список баз даних, які використовються на сервері


	sqlmap -u http://site.com/page.php?id=23 -D studdb -tables
	вивести дані по студ-дб таблиці

	sqlmap -u http://site.com/page.php?id=23 -D studdb -t admin --columns
	переглядаємо всі таблиці з колонки адмін в таблиці студ-дб

## SQL inject me

доповнення для фаерфокса (картінка): шукає всі форми з відправленням запитів; має в базі перелік тестів які виконуються.

## havij

# Методи захисту

існує декілька способів щоб знайти SQL-injection:
- black/white box
- fuzzing - спосіб тестування в основі якого лежить некорректних, випадкових або непередбачуваних логікою додатка даних. Найчастіше використовується при блекбокс тестуванні
- Аналіз вихідного коду (ручний/автоматичний/статичний)

при захисту веб-сайта використовується:
- фільтрація данних
- не довіряти користувацькому вводу
- при порівнянні використовувати лапки: where name='$name'
- якщо використовуєте лайк, то екранувати символи процент і нижнє підкреслювання
- використовувати whitelist дозволених функцій

в пхп використовуються наступні функції:
- mysql_escape_string - екранує строку для використання mysql query
- addslashes - екранує спец-символи в строці
- htmlspecialchars - перетворює спеціальні символи в хтмл-сутності

Способи атаки:
1. mysql_real_escape_string


	9999 or 1=1										|	a' or 'a'='a
													|
	$id=mysql_real_escape_string($_GET['id']);		| 
	SELECT name FROM products						| SELECT id from products
	WHERE id=9999 or 1=1							| WHERE name='a\' or \'a\'=\'a'
													|
													|

2. функція приведення типу - intval()

	intval($_GET['id'])

3. функція preg_match()

	preg_match('/\s/') - екранує пробільні символи
	preg_match('/[\"]/') - екранує кавички
	preg_match('/[\\\\]/') - екранує слеші

4. placeholders (mysqli, pdo):
- Серверний
- Клієнтський

	if($stud = $mysqli = prepare('SELECT username FROM user WHERE state=?'))
	{
		$stud->bired_param("s", s$sdfgfnc)
		$stud->execute
		$stud->fired_result($username)
		$stud->fetch()
	}
	$stud->close()

В запит повинні потраляти лише варіанти виводу, базуючись на користувацькому вводі. Зазвичай ці варіанти утворені масивом констант, наприклад: 
- якщо є сайт по продажі комп-техніки, то в цьому масиві можуть бути такі сутності як процесори, мат-плати і більше нічого. Якщо ви виконуєте запит з фільтрацією, то зловмисник може використати константи. Але ми можемо порівнювати фільтр і константи із білим списком і гарантувати 100% захищенності.

## Як обходити такі захисти

### Ін'єкція 0-byte

в сі строки закінчуються на /0

### Змішаний вміст

якщо  мова використовує регістро-незалежні вирази, то можно цим скористатись

	<script>
	<sCRiPt>

### Вбудовані коментарі

	/*!SELECT */

умови при яких проходять атаки:
1. нормалізація запиту у функціях проходження
2. застосування технологій HPP та HPF

### обхід правил фільтрацій (обхід сигнатури)

Уявіть що ви пишете юніон-бейсд атаку. Змінюєте "UNION" на наступне:

	/* !%55NiOn */
	/* !%53eLEct*/

	SEL/**/ECT

### уразливості логіки самого додатка

наступна лаба: тестуєте ваш веб-додаток на ін'єкцію

берете те що у вас є, за допомогою скл-мап або склінжектмі тестуєте і робите пару скриншоті а потім починаєте їх видаляти і в кінці знову тестуєте (зробити звіт і показати з екрану)